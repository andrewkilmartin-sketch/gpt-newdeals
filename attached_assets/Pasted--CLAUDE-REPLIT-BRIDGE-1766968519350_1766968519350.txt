/**

- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
- CLAUDE â†” REPLIT BRIDGE v1.0
- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
- 
- SETUP (one time):
- 1. Save this as: claude-bridge.js
- 1. Create file: claude-input.json (paste Claudeâ€™s instructions here)
- 1. Run: node claude-bridge.js
- 
- WORKFLOW:
- 1. Claude gives you JSON â†’ paste into claude-input.json
- 1. This script auto-runs it
- 1. Copy claude-output.json â†’ paste to Claude
- 1. Repeat!
- 
- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  */

const fs = require(â€˜fsâ€™);
const { execSync } = require(â€˜child_processâ€™);

const INPUT = â€˜./claude-input.jsonâ€™;
const OUTPUT = â€˜./claude-output.jsonâ€™;
const API = process.env.BASE_URL || â€˜http://localhost:3000â€™;

// Create input file if missing
if (!fs.existsSync(INPUT)) {
fs.writeFileSync(INPUT, â€˜{â€œactionâ€:â€œwaitingâ€}â€™);
}

console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  ğŸ¤– CLAUDE â†” REPLIT BRIDGE ACTIVE                             â•‘
â•‘                                                               â•‘
â•‘  Input:  ${INPUT.padEnd(50)}â•‘
â•‘  Output: ${OUTPUT.padEnd(50)}â•‘
â•‘  API:    ${API.padEnd(50)}â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Watching for Claudeâ€™s instructionsâ€¦
`);

let lastHash = â€˜â€™;

async function run() {
try {
const raw = fs.readFileSync(INPUT, â€˜utf8â€™);
const hash = Buffer.from(raw).toString(â€˜base64â€™).slice(0, 20);

```
if (hash === lastHash) return;
lastHash = hash;

const input = JSON.parse(raw);
if (input.action === 'waiting') return;

console.log(`\nâš¡ Running: ${input.action}`);

const result = await execute(input);

fs.writeFileSync(OUTPUT, JSON.stringify(result, null, 2));
console.log(`âœ… Done â†’ ${OUTPUT}`);
```

} catch (e) {
fs.writeFileSync(OUTPUT, JSON.stringify({ error: e.message }, null, 2));
}
}

async function execute(input) {
const out = { action: input.action, time: new Date().toISOString(), ok: false };

switch (input.action) {

```
case 'health':
  out.data = await api('/sunny/health');
  out.ok = true;
  break;

case 'chat':
  out.data = await api('/sunny/chat', { message: input.message });
  out.ok = out.data?.success;
  break;

case 'conversation':
  out.data = [];
  for (const msg of input.messages) {
    const r = await api('/sunny/chat', { message: msg });
    out.data.push({ user: msg, sunny: r.response, debug: r.debug });
    await sleep(300);
  }
  out.ok = true;
  break;

case 'test-all':
  out.data = await runTests();
  out.ok = out.data.failed === 0;
  break;

case 'test-one':
  out.data = await runSingleTest(input.test);
  out.ok = out.data.pass;
  break;

case 'api-check':
  out.data = await api(input.endpoint);
  out.ok = true;
  break;

case 'read':
  out.data = fs.readFileSync(input.file, 'utf8');
  out.ok = true;
  break;

case 'write':
  fs.writeFileSync(input.file, input.content);
  out.ok = true;
  out.data = { wrote: input.file };
  break;

case 'shell':
  try {
    out.data = execSync(input.cmd, { encoding: 'utf8', timeout: 30000 });
    out.ok = true;
  } catch (e) {
    out.data = e.stderr || e.message;
  }
  break;

case 'full-test':
  out.data = await fullUserTest();
  out.ok = out.data.issues === 0;
  break;
  
default:
  out.error = `Unknown: ${input.action}`;
```

}

return out;
}

async function api(endpoint, body = null) {
const opts = { headers: { â€˜Content-Typeâ€™: â€˜application/jsonâ€™ } };
if (body) {
opts.method = â€˜POSTâ€™;
opts.body = JSON.stringify(body);
}
const r = await fetch(`${API}${endpoint}`, opts);
return r.json();
}

function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TESTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function runTests() {
const tests = [
[â€˜healthâ€™, async () => (await api(â€™/sunny/healthâ€™)).version?.includes(â€˜v2â€™)],
[â€˜greetingâ€™, async () => (await api(â€™/sunny/chatâ€™, { message: â€˜Hiâ€™ })).success],
[â€˜safariâ€™, async () => {
const r = await api(â€™/sunny/chatâ€™, { message: â€˜Safari parks Birminghamâ€™ });
return r.response?.toLowerCase().includes(â€˜kids passâ€™);
}],
[â€˜cinemaâ€™, async () => {
const r = await api(â€™/sunny/chatâ€™, { message: â€œWhatâ€™s on at cinemaâ€ });
return r.response?.toLowerCase().includes(â€˜kids passâ€™);
}],
[â€˜movie-nightâ€™, async () => {
const r = await api(â€™/sunny/chatâ€™, { message: â€˜Netflix film tonightâ€™ });
return !r.response?.includes(â€˜kidspass.co.uk/cinemaâ€™); // Should NOT show cinema promo
}],
[â€˜no-hallucinateâ€™, async () => {
const r = await api(â€™/sunny/chatâ€™, { message: â€˜Safari parks Midlandsâ€™ });
const apiNames = r.debug?.apiResults?.flatMap(x => x.names || []) || [];
const mentions = r.response?.match(/Longleat|Whipsnade|Chester/gi) || [];
return mentions.every(m => apiNames.some(n => n?.toLowerCase().includes(m.toLowerCase())));
}],
[â€˜restaurantsâ€™, async () => {
const r = await api(â€™/sunny/chatâ€™, { message: â€˜Places to eat with kidsâ€™ });
return r.response?.toLowerCase().includes(â€˜kids passâ€™);
}],
[â€˜theme-parksâ€™, async () => {
const r = await api(â€™/sunny/chatâ€™, { message: â€˜Theme parks near Londonâ€™ });
return r.response?.toLowerCase().includes(â€˜kids passâ€™);
}]
];

const results = { passed: 0, failed: 0, details: [] };

for (const [name, fn] of tests) {
try {
const pass = await fn();
results.details.push({ name, pass });
pass ? results.passed++ : results.failed++;
} catch (e) {
results.details.push({ name, pass: false, error: e.message });
results.failed++;
}
}

return results;
}

async function runSingleTest(name) {
const r = await api(â€™/sunny/chatâ€™, { message: name });
return {
pass: r.success,
response: r.response?.substring(0, 500),
debug: r.debug
};
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FULL USER SIMULATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function fullUserTest() {
const users = [
{ name: â€˜Sarahâ€™, msgs: [â€˜Hiâ€™, â€˜Soft play Birminghamâ€™, â€˜Actually staying in, whats on Netflix?â€™] },
{ name: â€˜Daveâ€™, msgs: [â€˜Theme parks near London with dealsâ€™] },
{ name: â€˜Emmaâ€™, msgs: [â€˜Places to eat with kids Manchesterâ€™] },
{ name: â€˜Tomâ€™, msgs: [â€˜Film for tonight on Disney plusâ€™, â€˜What snacks should we get?â€™] },
{ name: â€˜Lisaâ€™, msgs: [â€˜Safari parks near meâ€™] }
];

const results = { users: [], issues: 0, hallucinations: [] };

for (const u of users) {
const convos = [];
for (const m of u.msgs) {
const r = await api(â€™/sunny/chatâ€™, { message: m });

```
  // Check for hallucinations
  const apiNames = r.debug?.apiResults?.flatMap(x => x.names?.map(n => n.toLowerCase()) || []) || [];
  const badMentions = ['longleat', 'alton towers', 'thorpe park', 'chessington', 'legoland'];
  
  for (const bad of badMentions) {
    if (r.response?.toLowerCase().includes(bad) && !apiNames.some(n => n.includes(bad))) {
      results.hallucinations.push({ user: u.name, mentioned: bad, apiHad: apiNames });
      results.issues++;
    }
  }
  
  convos.push({
    user: m,
    sunny: r.response?.substring(0, 300) + (r.response?.length > 300 ? '...' : ''),
    intents: r.debug?.intents?.map(i => i.type),
    apiNames: apiNames.slice(0, 5)
  });
  
  await sleep(200);
}
results.users.push({ name: u.name, convos });
```

}

return results;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// WATCH LOOP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

setInterval(run, 1500);
run();