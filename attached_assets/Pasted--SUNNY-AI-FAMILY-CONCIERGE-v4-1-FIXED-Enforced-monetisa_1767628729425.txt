/**

- SUNNY AI FAMILY CONCIERGE v4.1
- FIXED: Enforced monetisation, proper sponsor strip, structured Kids Pass CTAs
- 
- CHANGES FROM v4.0:
- - Commerce triggers FORCE product searches for relevant queries
- - Sponsor strip APPENDED to response text (not separate field)
- - Kids Pass CTAs with ACTUAL LINKS and PERCENTAGES
- - Stronger system prompt requiring monetisation
    */

import OpenAI from â€œopenaiâ€;
import { db } from â€œ./dbâ€;
import { chatLogs } from â€œ@shared/schemaâ€;
import { v4 as uuidv4 } from â€œuuidâ€;

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

// ============================================================================
// SYSTEM PROMPT - Now with ENFORCED monetisation rules
// ============================================================================

const SYSTEM_PROMPT = `You are Sunny, a warm and helpful family concierge for UK families.

PERSONALITY:
Like a friend whoâ€™s done it all with their own kids - genuine, helpful, natural. Use 1-2 emojis. No bullet lists unless showing multiple options. Just talk.

CRITICAL DATA RULES:

- ONLY recommend what your tools return - never invent venues, products, or links
- If search returns nothing, say so honestly

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
MONETISATION RULES - YOU MUST FOLLOW THESE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

KIDS PASS - ALWAYS include when recommending PAID attractions:
Format: â€œKids Pass saves you [X]% - [LINK]â€
Use these EXACT links:

- Zoos/Safari: https://www.kidspass.co.uk/zoos (saves up to 40%)
- Theme Parks: https://www.kidspass.co.uk/theme-parks (saves up to 35%)
- Cinema: https://www.kidspass.co.uk/cinema (saves up to 40%)
- Soft Play/Indoor: https://www.kidspass.co.uk/indoor-activities (saves up to 50%)
- Restaurants: https://www.kidspass.co.uk/restaurants (saves up to 50%)
- Aquariums: https://www.kidspass.co.uk/aquariums (saves up to 40%)

AWIN PRODUCTS - You MUST call search_products for these triggers:

- Zoo/Safari/Animals â†’ search â€œbinocularsâ€ or â€œanimal toysâ€
- Theme park/Day out â†’ search â€œsun hatâ€ or â€œponchoâ€ or â€œwater bottleâ€
- Cinema â†’ search â€œsweetsâ€ or â€œsnacksâ€
- Movie night/Streaming/Night in â†’ search â€œblanketâ€ or â€œpopcornâ€ or â€œpyjamasâ€
- Beach â†’ search â€œbucket spadeâ€ or â€œbeach towelâ€
- Restaurant â†’ search â€œcolouring bookâ€ or â€œactivity bookâ€
- Rainy day â†’ search â€œcraft kitâ€ or â€œboard gameâ€
- Birthday â†’ search â€œparty bagsâ€ or â€œbirthdayâ€

When you get product results, INCLUDE them naturally:
â€œGrab some [Product Name] (Â£X from [Merchant]) - [affiliate link]â€

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

RESPONSE STRUCTURE:

1. Answer their question with real data
1. Include Kids Pass link with savings % if paid attractions
1. Include 1-2 relevant Awin products with prices and links
1. Ask a follow-up question

LOCATION: If they say â€œnear meâ€ without context, ask â€œWhat area are you in?â€

Keep responses conversational, under 200 words.`;

// ============================================================================
// TOOL DEFINITIONS
// ============================================================================

const tools: OpenAI.Chat.Completions.ChatCompletionTool[] = [
{
type: â€œfunctionâ€,
function: {
name: â€œsearch_attractionsâ€,
description: â€œSearch paid UK attractions - theme parks, zoos, safari parks, aquariums, soft play, bowling, museums. Use for any â€˜days outâ€™ or â€˜things to doâ€™ queries.â€,
parameters: {
type: â€œobjectâ€,
properties: {
query: { type: â€œstringâ€, description: â€œWhat theyâ€™re looking for: zoo, theme park, soft play, bowling, museum, farm, etc.â€ },
location: { type: â€œstringâ€, description: â€œCity or area - MUST match userâ€™s requested locationâ€ },
limit: { type: â€œnumberâ€, description: â€œMax results, default 5â€ }
},
required: [â€œqueryâ€]
}
}
},
{
type: â€œfunctionâ€,
function: {
name: â€œsearch_attractions_freeâ€,
description: â€œSearch FREE UK attractions - parks, museums, galleries, beaches. Use when they mention â€˜freeâ€™, â€˜cheapâ€™, or â€˜budgetâ€™.â€,
parameters: {
type: â€œobjectâ€,
properties: {
query: { type: â€œstringâ€, description: â€œWhat theyâ€™re looking forâ€ },
location: { type: â€œstringâ€, description: â€œCity or areaâ€ },
limit: { type: â€œnumberâ€, description: â€œMax results, default 5â€ }
},
required: [â€œqueryâ€]
}
}
},
{
type: â€œfunctionâ€,
function: {
name: â€œsearch_cinemaâ€,
description: â€œFind films currently showing at UK cinemas. For FAMILIES, always set family=true.â€,
parameters: {
type: â€œobjectâ€,
properties: {
genre: { type: â€œstringâ€, description: â€œfamily, animation, comedy, actionâ€ },
family: { type: â€œbooleanâ€, description: â€œSet TRUE for families with kids - filters to U/PG onlyâ€ },
limit: { type: â€œnumberâ€, description: â€œMax results, default 5â€ }
}
}
}
},
{
type: â€œfunctionâ€,
function: {
name: â€œsearch_streamingâ€,
description: â€œFind films to watch at home on Netflix, Disney+, Prime Video. ALWAYS call search_products for blankets/popcorn/pyjamas after this.â€,
parameters: {
type: â€œobjectâ€,
properties: {
service: { type: â€œstringâ€, description: â€œNetflix, Disney+, Prime Video, NOW, Skyâ€ },
mood: { type: â€œstringâ€, description: â€œFun, Heartwarming, Adventure, Scaryâ€ },
family: { type: â€œbooleanâ€, description: â€œSet TRUE for family-friendly filmsâ€ },
limit: { type: â€œnumberâ€, description: â€œMax results, default 5â€ }
}
}
}
},
{
type: â€œfunctionâ€,
function: {
name: â€œsearch_activitiesâ€,
description: â€œFind things to do AT HOME - crafts, games, rainy day ideas. NOT for days out.â€,
parameters: {
type: â€œobjectâ€,
properties: {
setting: { type: â€œstringâ€, description: â€œINDOOR, OUTDOOR, or CARâ€ },
age: { type: â€œnumberâ€, description: â€œChildâ€™s ageâ€ },
energy: { type: â€œstringâ€, description: â€œLOW, MED, or HIGHâ€ },
limit: { type: â€œnumberâ€, description: â€œMax results, default 5â€ }
}
}
}
},
{
type: â€œfunctionâ€,
function: {
name: â€œsearch_productsâ€,
description: â€œSearch Awin affiliate products - toys, clothes, gifts, supplies. YOU MUST CALL THIS for: movie nights (blankets, popcorn), zoo trips (binoculars), theme parks (sun hats), cinema (snacks), beach (towels), restaurants (colouring books).â€,
parameters: {
type: â€œobjectâ€,
properties: {
query: { type: â€œstringâ€, description: â€œSpecific product: binoculars, blanket, popcorn, pyjamas, sun hat, snacks, party bags, etc.â€ },
limit: { type: â€œnumberâ€, description: â€œMax results, default 3â€ }
},
required: [â€œqueryâ€]
}
}
},
{
type: â€œfunctionâ€,
function: {
name: â€œsearch_eventsâ€,
description: â€œFind family events, shows, live entertainment. Filter by family-appropriate content when kids are mentioned.â€,
parameters: {
type: â€œobjectâ€,
properties: {
query: { type: â€œstringâ€, description: â€œEvent type or nameâ€ },
city: { type: â€œstringâ€, description: â€œCity - MUST match userâ€™s requested locationâ€ },
limit: { type: â€œnumberâ€, description: â€œMax results, default 5â€ }
}
}
}
},
{
type: â€œfunctionâ€,
function: {
name: â€œsearch_restaurantsâ€,
description: â€œFind family-friendly restaurants with kids menus.â€,
parameters: {
type: â€œobjectâ€,
properties: {
city: { type: â€œstringâ€, description: â€œCity - MUST match userâ€™s requested location exactlyâ€ },
chain: { type: â€œstringâ€, description: â€œSpecific chain: Harvester, Beefeater, Toby Carveryâ€ },
limit: { type: â€œnumberâ€, description: â€œMax results, default 5â€ }
},
required: [â€œcityâ€]
}
}
},
{
type: â€œfunctionâ€,
function: {
name: â€œsearch_recommendationsâ€,
description: â€œGet community-sourced venue recommendations from parent groups.â€,
parameters: {
type: â€œobjectâ€,
properties: {
query: { type: â€œstringâ€, description: â€œVenue or categoryâ€ },
limit: { type: â€œnumberâ€, description: â€œMax results, default 5â€ }
}
}
}
}
];

// ============================================================================
// TOOL EXECUTION
// ============================================================================

const BASE_URL = `http://localhost:${process.env.PORT || 5000}`;

async function executeTool(name: string, args: Record<string, unknown>): Promise<unknown> {
const limit = (args.limit as number) || 5;

try {
let url: string;

```
switch (name) {
  case "search_attractions":
    url = `${BASE_URL}/attractions/search?query=${encodeURIComponent(args.query as string || "")}&location=${encodeURIComponent(args.location as string || "")}&limit=${limit}`;
    break;
    
  case "search_attractions_free":
    url = `${BASE_URL}/attractions/free?query=${encodeURIComponent(args.query as string || "")}&location=${encodeURIComponent(args.location as string || "")}&limit=${limit}`;
    break;
    
  case "search_cinema":
    url = `${BASE_URL}/cinema/search?family=${args.family !== false}&limit=${limit}`;
    if (args.genre) url += `&genre=${encodeURIComponent(args.genre as string)}`;
    break;
    
  case "search_streaming":
    url = `${BASE_URL}/nightin/search?family=${args.family !== false}&limit=${limit}`;
    if (args.service) url += `&service=${encodeURIComponent(args.service as string)}`;
    if (args.mood) url += `&mood=${encodeURIComponent(args.mood as string)}`;
    break;
    
  case "search_activities":
    url = `${BASE_URL}/activities/search?limit=${limit}`;
    if (args.setting) url += `&setting=${encodeURIComponent(args.setting as string)}`;
    if (args.age) url += `&age=${args.age}`;
    if (args.energy) url += `&energy=${encodeURIComponent(args.energy as string)}`;
    break;
    
  case "search_products":
    url = `${BASE_URL}/shopping/awin-link?query=${encodeURIComponent(args.query as string || "")}&limit=${limit}`;
    break;
    
  case "search_events":
    url = `${BASE_URL}/events/search?limit=${limit}`;
    if (args.query) url += `&query=${encodeURIComponent(args.query as string)}`;
    if (args.city) url += `&city=${encodeURIComponent(args.city as string)}`;
    break;
    
  case "search_restaurants":
    url = `${BASE_URL}/restaurants/search?limit=${limit}`;
    if (args.city) url += `&city=${encodeURIComponent(args.city as string)}`;
    if (args.chain) url += `&chain=${encodeURIComponent(args.chain as string)}`;
    break;
    
  case "search_recommendations":
    url = `${BASE_URL}/recommendations/search?limit=${limit}`;
    if (args.query) url += `&query=${encodeURIComponent(args.query as string)}`;
    break;
    
  default:
    return { error: `Unknown tool: ${name}` };
}

const response = await fetch(url);
const data = await response.json();
return data;
```

} catch (error) {
console.error(`Tool ${name} failed:`, error);
return { error: `Failed to search: ${error}` };
}
}

// ============================================================================
// COMMERCE TRIGGERS - Force product searches for relevant queries
// ============================================================================

interface CommerceTrigger {
keywords: string[];
productSearches: string[];
}

const COMMERCE_TRIGGERS: CommerceTrigger[] = [
{
keywords: [â€œzooâ€, â€œsafariâ€, â€œanimalâ€, â€œwildlifeâ€, â€œfarmâ€],
productSearches: [â€œbinocularsâ€, â€œanimal toysâ€]
},
{
keywords: [â€œtheme parkâ€, â€œadventureâ€, â€œrollercoasterâ€, â€œday outâ€, â€œattractionâ€],
productSearches: [â€œsun hatâ€, â€œwater bottleâ€]
},
{
keywords: [â€œcinemaâ€, â€œfilmâ€, â€œmovieâ€, â€œpicturesâ€],
productSearches: [â€œsweetsâ€, â€œsnacksâ€]
},
{
keywords: [â€œstreamingâ€, â€œnetflixâ€, â€œdisneyâ€, â€œnight inâ€, â€œmovie nightâ€, â€œwatchâ€],
productSearches: [â€œblanketâ€, â€œpopcornâ€, â€œpyjamasâ€]
},
{
keywords: [â€œbeachâ€, â€œseasideâ€, â€œcoastâ€],
productSearches: [â€œbucket spadeâ€, â€œbeach towelâ€]
},
{
keywords: [â€œrestaurantâ€, â€œeatâ€, â€œdinnerâ€, â€œlunchâ€, â€œfoodâ€],
productSearches: [â€œcolouring bookâ€, â€œactivity bookâ€]
},
{
keywords: [â€œrainyâ€, â€œindoorâ€, â€œboredâ€, â€œhomeâ€],
productSearches: [â€œcraft kitâ€, â€œboard gameâ€]
},
{
keywords: [â€œbirthdayâ€, â€œpartyâ€],
productSearches: [â€œparty bagsâ€, â€œbirthday decorationsâ€]
},
{
keywords: [â€œsoft playâ€, â€œtrampolineâ€, â€œbowlingâ€],
productSearches: [â€œgrip socksâ€, â€œsnacksâ€]
}
];

function detectCommerceTriggers(message: string): string[] {
const lowerMessage = message.toLowerCase();
const productSearches: string[] = [];

for (const trigger of COMMERCE_TRIGGERS) {
if (trigger.keywords.some(keyword => lowerMessage.includes(keyword))) {
productSearches.push(â€¦trigger.productSearches);
}
}

// Return unique searches, max 2
return [â€¦new Set(productSearches)].slice(0, 2);
}

// ============================================================================
// SPONSOR STRIP - Appended to EVERY response
// ============================================================================

interface SponsorDeal {
merchant: string;
offer: string;
link: string;
}

async function getSponsorStrip(): Promise<SponsorDeal[]> {
try {
const categories = [â€œtoysâ€, â€œkidsâ€, â€œfamilyâ€, â€œclothingâ€, â€œgamesâ€];
const randomCategory = categories[Math.floor(Math.random() * categories.length)];

```
const response = await fetch(`${BASE_URL}/shopping/awin-link?query=${randomCategory}&limit=3`);
const data = await response.json();

if (data.results && data.results.length > 0) {
  return data.results.slice(0, 3).map((product: any) => ({
    merchant: product.merchant || "Retailer",
    offer: product.salePrice 
      ? `${Math.round((1 - product.salePrice / product.price) * 100)}% off`
      : "deals available",
    link: product.affiliateLink || product.affiliate_link || "#"
  }));
}

return [
  { merchant: "Zavvi", offer: "50% off toys", link: "https://www.awin1.com/cread.php?awinmid=599&awinaffid=511345" },
  { merchant: "Debenhams", offer: "Kids sale", link: "https://www.awin1.com/cread.php?awinmid=2228&awinaffid=511345" },
  { merchant: "Wowow Toys", offer: "Free delivery Â£20+", link: "https://www.awin1.com/cread.php?awinmid=19909&awinaffid=511345" }
];
```

} catch (error) {
console.error(â€œSponsor strip fetch failed:â€, error);
return [];
}
}

function formatSponsorStrip(sponsors: SponsorDeal[]): string {
if (sponsors.length === 0) return â€œâ€;

const deals = sponsors.map(s => `[${s.merchant}](${s.link}): ${s.offer}`).join(â€ â€¢ â€œ);
return `\n\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nğŸ’° Today's deals: ${deals}`;
}

// ============================================================================
// SESSION MANAGEMENT
// ============================================================================

interface ConversationMessage {
role: â€œuserâ€ | â€œassistantâ€ | â€œsystemâ€;
content: string;
}

interface Session {
id: string;
messages: ConversationMessage[];
createdAt: Date;
lastActivity: Date;
}

const sessions = new Map<string, Session>();

function getOrCreateSession(sessionId?: string): Session {
if (sessionId && sessions.has(sessionId)) {
const session = sessions.get(sessionId)!;
session.lastActivity = new Date();
return session;
}

const newSession: Session = {
id: sessionId || uuidv4(),
messages: [{ role: â€œsystemâ€, content: SYSTEM_PROMPT }],
createdAt: new Date(),
lastActivity: new Date()
};

sessions.set(newSession.id, newSession);
return newSession;
}

setInterval(() => {
const oneHourAgo = Date.now() - 60 * 60 * 1000;
for (const [id, session] of sessions) {
if (session.lastActivity.getTime() < oneHourAgo) {
sessions.delete(id);
}
}
}, 60 * 60 * 1000);

// ============================================================================
// URL SANITIZATION
// ============================================================================

function sanitizeResponse(text: string): string {
return text
.replace(/https?://(www.)?(example.com|fake.com|placeholder.com)[^\s)â€]*/gi, â€œ[link removed]â€)
.replace(/https?://(www.)?amazon.(com|co.uk)[^\s)â€]*/gi, â€œ[link removed]â€)
.replace(/[([^]]+)](https?://(www.)?(example|fake|placeholder).[^)]+)/gi, â€œ$1â€);
}

// ============================================================================
// MAIN CHAT HANDLER
// ============================================================================

export async function handleChat(
message: string,
sessionId?: string
): Promise<{ success: boolean; response: string; sessionId: string; debug?: unknown }> {

const session = getOrCreateSession(sessionId);
const toolsUsed: { tool: string; args: unknown; resultCount?: number }[] = [];

try {
// Add user message to history
session.messages.push({ role: â€œuserâ€, content: message });

```
// Detect commerce triggers - we'll force these if AI doesn't call them
const requiredProductSearches = detectCommerceTriggers(message);

// First OpenAI call
const firstResponse = await openai.chat.completions.create({
  model: "gpt-4o-mini",
  messages: session.messages as OpenAI.Chat.Completions.ChatCompletionMessageParam[],
  tools,
  tool_choice: "auto",
  max_tokens: 1000
});

const firstChoice = firstResponse.choices[0];
let finalResponse: string;

if (firstChoice.message.tool_calls && firstChoice.message.tool_calls.length > 0) {
  const toolMessages: OpenAI.Chat.Completions.ChatCompletionMessageParam[] = [
    firstChoice.message as OpenAI.Chat.Completions.ChatCompletionMessageParam
  ];
  
  // Track which product searches were made
  const productSearchesMade: string[] = [];
  
  for (const toolCall of firstChoice.message.tool_calls) {
    const args = JSON.parse(toolCall.function.arguments);
    const result = await executeTool(toolCall.function.name, args);
    
    if (toolCall.function.name === "search_products") {
      productSearchesMade.push(args.query);
    }
    
    toolsUsed.push({
      tool: toolCall.function.name,
      args,
      resultCount: Array.isArray((result as any).results) ? (result as any).results.length : undefined
    });
    
    toolMessages.push({
      role: "tool",
      tool_call_id: toolCall.id,
      content: JSON.stringify(result)
    });
  }
  
  // FORCE product searches if AI didn't make them
  for (const requiredSearch of requiredProductSearches) {
    if (!productSearchesMade.some(s => s.toLowerCase().includes(requiredSearch.toLowerCase()))) {
      const productResult = await executeTool("search_products", { query: requiredSearch, limit: 2 });
      
      toolsUsed.push({
        tool: "search_products (forced)",
        args: { query: requiredSearch },
        resultCount: Array.isArray((productResult as any).results) ? (productResult as any).results.length : undefined
      });
      
      // Add as additional context
      toolMessages.push({
        role: "tool",
        tool_call_id: `forced-${requiredSearch}`,
        content: `ADDITIONAL PRODUCT SUGGESTION - Include this naturally: ${JSON.stringify(productResult)}`
      } as any);
    }
  }
  
  // Second OpenAI call
  const secondResponse = await openai.chat.completions.create({
    model: "gpt-4o-mini",
    messages: [
      ...session.messages as OpenAI.Chat.Completions.ChatCompletionMessageParam[],
      ...toolMessages
    ],
    tools,
    tool_choice: "none",
    max_tokens: 1000
  });
  
  finalResponse = secondResponse.choices[0].message.content || "Sorry, I couldn't find anything for that.";
  
} else {
  // No tools called - but we might still need products
  if (requiredProductSearches.length > 0) {
    // Force product searches even for simple queries
    const productResults: any[] = [];
    for (const search of requiredProductSearches) {
      const result = await executeTool("search_products", { query: search, limit: 2 });
      productResults.push({ query: search, result });
      toolsUsed.push({
        tool: "search_products (forced)",
        args: { query: search }
      });
    }
    
    // Re-run with product context
    const withProducts = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        ...session.messages as OpenAI.Chat.Completions.ChatCompletionMessageParam[],
        {
          role: "system",
          content: `Include these relevant products naturally in your response: ${JSON.stringify(productResults)}`
        }
      ],
      max_tokens: 1000
    });
    
    finalResponse = withProducts.choices[0].message.content || firstChoice.message.content || "Sorry, I'm not sure how to help with that.";
  } else {
    finalResponse = firstChoice.message.content || "Sorry, I'm not sure how to help with that.";
  }
}

// Sanitize
finalResponse = sanitizeResponse(finalResponse);

// ALWAYS append sponsor strip
const sponsors = await getSponsorStrip();
const sponsorStrip = formatSponsorStrip(sponsors);
finalResponse = finalResponse + sponsorStrip;

// Add to session
session.messages.push({ role: "assistant", content: finalResponse });

// Trim history
if (session.messages.length > 21) {
  session.messages = [
    session.messages[0],
    ...session.messages.slice(-20)
  ];
}

// Log to database
try {
  await db.insert(chatLogs).values({
    id: uuidv4(),
    sessionId: session.id,
    userMessage: message,
    sunnyResponse: finalResponse,
    toolsUsed: JSON.stringify(toolsUsed),
    createdAt: new Date()
  });
} catch (dbError) {
  console.error("Failed to log chat:", dbError);
}

return {
  success: true,
  response: finalResponse,
  sessionId: session.id,
  debug: {
    version: "v4.1-monetised",
    toolsUsed,
    commerceTriggersDetected: requiredProductSearches
  }
};
```

} catch (error) {
console.error(â€œChat error:â€, error);
return {
success: false,
response: â€œSorry, something went wrong. Give me a sec and try again! ğŸ˜Šâ€,
sessionId: session.id,
debug: { error: String(error) }
};
}
}

// ============================================================================
// EXPRESS ROUTES
// ============================================================================

import { Router, Request, Response } from â€œexpressâ€;

export const sunnyRouter = Router();

sunnyRouter.post(â€/chatâ€, async (req: Request, res: Response) => {
const { message, sessionId } = req.body;

if (!message || typeof message !== â€œstringâ€ || message.trim().length === 0) {
return res.status(400).json({ success: false, error: â€œMessage requiredâ€ });
}

const result = await handleChat(message.trim(), sessionId);
res.json(result);
});

sunnyRouter.get(â€/healthâ€, (_req: Request, res: Response) => {
res.json({
status: â€œSunny v4.1 - Monetisedâ€,
version: â€œv4.1-monetisedâ€,
activeSessions: sessions.size,
timestamp: new Date().toISOString()
});
});

sunnyRouter.get(â€/historyâ€, async (req: Request, res: Response) => {
try {
const limit = Math.min(parseInt(req.query.limit as string) || 50, 100);
const logs = await db.select().from(chatLogs).limit(limit);

```
res.json({
  success: true,
  count: logs.length,
  logs: logs.map(log => ({
    ...log,
    sunnyResponse: req.query.full === "true" ? log.sunnyResponse : log.sunnyResponse?.substring(0, 100) + "..."
  }))
});
```

} catch (error) {
res.status(500).json({ success: false, error: String(error) });
}
});

sunnyRouter.get(â€/diagnosticsâ€, (_req: Request, res: Response) => {
res.json({
version: â€œv4.1-monetisedâ€,
systemPromptLength: SYSTEM_PROMPT.length,
toolCount: tools.length,
commerceTriggers: COMMERCE_TRIGGERS.length,
activeSessions: sessions.size,
timestamp: new Date().toISOString()
});
});

export default sunnyRouter;