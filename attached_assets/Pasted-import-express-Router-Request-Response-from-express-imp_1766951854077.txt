import express, { Router, Request, Response } from 'express';
import OpenAI from 'openai';

const router: Router = express.Router();

// Uses your existing OpenAI setup from Replit
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
});

// Your API base URL (calling yourself)
const API_BASE = process.env.REPLIT_URL || 'https://endpoint-weaver--rcxpysgzgc.replit.app';

// ===========================================
// STEP 1: INTENT CLASSIFICATION
// GPT's ONLY job: understand what user wants
// ===========================================

interface Intent {
  type: string;
  confidence: number;
  parameters: {
    query?: string;
    location?: string;
    category?: string;
    limit?: number;
  };
}

interface Classification {
  intents: Intent[];
}

async function classifyIntent(userMessage: string): Promise<Classification> {
  const response = await openai.chat.completions.create({
    model: 'gpt-4o-mini', // Fast and cheap
    messages: [
      {
        role: 'system',
        content: `You classify user messages for a UK family concierge service.

INTENTS (pick ALL that apply):
- ATTRACTION: Days out, theme parks, zoos, safari parks, aquariums, museums
- CINEMA: Films at cinemas, "pictures", "what's showing", Odeon, Vue
- HOME_MOVIE: Streaming, Netflix, Disney+, "night in", "film at home"
- ACTIVITY: Kids activities, "bored", rainy day, crafts, games
- SHOPPING: Products, toys, clothes, gifts
- TIPS: Money saving, deals, budget advice
- GREETING: Just saying hello (ONLY if nothing else)

Extract parameters:
- query: search terms
- location: UK city/area mentioned
- category: specific type (safari, italian, animation)
- limit: default 5

CRITICAL: 
- Multiple intents allowed: "safari parks and a film" = [ATTRACTION, HOME_MOVIE]
- "Hey" with a request = NOT a greeting, extract the request
- UK English: "pictures"=cinema, "telly"=TV

Return JSON only:
{"intents":[{"type":"INTENT_TYPE","confidence":0.9,"parameters":{"query":"...","location":"..."}}]}`
      },
      { role: 'user', content: userMessage }
    ],
    response_format: { type: 'json_object' },
    temperature: 0.1 // Low = consistent
  });

  try {
    return JSON.parse(response.choices[0].message.content || '{"intents":[]}');
  } catch {
    return { intents: [{ type: 'GREETING', confidence: 1, parameters: {} }] };
  }
}

// ===========================================
// STEP 2: FETCH FROM YOUR OWN ENDPOINTS
// No hallucination possible - it's YOUR data
// ===========================================

const ENDPOINTS: Record<string, string> = {
  ATTRACTION: '/attractions/search',
  CINEMA: '/cinema/search',
  HOME_MOVIE: '/nightin/search',
  ACTIVITY: '/activities/search',
  SHOPPING: '/shopping/awin-link',
  TIPS: '/hintsandtips/search'
};

async function fetchData(intent: Intent): Promise<any> {
  const endpoint = ENDPOINTS[intent.type];
  if (!endpoint) return null;

  const params = new URLSearchParams();
  if (intent.parameters.query) params.append('query', intent.parameters.query);
  if (intent.parameters.location) params.append('location', intent.parameters.location);
  if (intent.parameters.category) params.append('category', intent.parameters.category);
  params.append('limit', String(intent.parameters.limit || 5));

  try {
    const url = `${API_BASE}${endpoint}?${params.toString()}`;
    console.log(`Fetching: ${url}`);
    
    const response = await fetch(url);
    const data = await response.json();
    return { type: intent.type, results: data.results || [], count: data.count || 0 };
  } catch (error) {
    console.error(`Fetch error for ${intent.type}:`, error);
    return { type: intent.type, results: [], count: 0 };
  }
}

// ===========================================
// STEP 3: FIND UPSELLS (Tag matching)
// ===========================================

async function findUpsells(results: any[]): Promise<any[]> {
  // Collect keywords from results for upsell matching
  const keywords: string[] = [];
  
  results.forEach(r => {
    if (r.results) {
      r.results.slice(0, 3).forEach((item: any) => {
        const name = item.name || item.title || '';
        keywords.push(...name.toLowerCase().split(' ').filter((w: string) => w.length > 3));
      });
    }
  });

  if (keywords.length === 0) return [];

  try {
    const query = keywords.slice(0, 3).join(' ');
    const response = await fetch(`${API_BASE}/shopping/awin-link?query=${encodeURIComponent(query)}&limit=2`);
    const data = await response.json();
    return data.results || [];
  } catch {
    return [];
  }
}

// ===========================================
// STEP 4: GENERATE RESPONSE
// GPT makes it sound human, but ONLY uses your data
// ===========================================

async function generateResponse(
  userMessage: string,
  results: any[],
  upsells: any[]
): Promise<string> {
  
  // If no results at all
  const hasResults = results.some(r => r.results && r.results.length > 0);
  
  if (!hasResults) {
    return "I couldn't find anything matching that. Could you try being more specific, or ask about something else? I can help with days out, cinema, films at home, activities, and shopping deals!";
  }

  const response = await openai.chat.completions.create({
    model: 'gpt-4o-mini',
    messages: [
      {
        role: 'system',
        content: `You are Sunny, a warm family concierge for Kids Pass (UK).

CRITICAL RULES:
1. ONLY mention items from <data> below - never invent anything
2. ONLY use prices, ratings, names exactly as shown in <data>
3. Be warm and friendly, like a helpful friend
4. Keep it concise - families are busy
5. Use 1-2 emojis max
6. If upsells provided, mention ONE naturally (not salesy)
7. End with a helpful follow-up question

<data>
${JSON.stringify(results, null, 2)}
</data>

<upsells>
${JSON.stringify(upsells, null, 2)}
</upsells>

Respond conversationally to what they asked for. Show the key info (names, prices, Kids Pass savings). Be helpful, not robotic.`
      },
      { role: 'user', content: userMessage }
    ],
    temperature: 0.7
  });

  return response.choices[0].message.content || "Sorry, I had a moment there. Could you try again?";
}

// ===========================================
// THE MAIN ENDPOINT: /sunny/chat
// ===========================================

router.post('/chat', async (req: Request, res: Response) => {
  try {
    const { message } = req.body;
    
    if (!message) {
      return res.status(400).json({ error: 'Message required' });
    }

    console.log(`\n=== SUNNY REQUEST ===`);
    console.log(`User: ${message}`);

    // Step 1: Classify intent
    const classification = await classifyIntent(message);
    console.log(`Intents: ${classification.intents.map(i => i.type).join(', ')}`);

    // Step 2: Fetch data for each intent
    const results = await Promise.all(
      classification.intents
        .filter(i => ENDPOINTS[i.type])
        .map(intent => fetchData(intent))
    );
    console.log(`Results: ${results.map(r => `${r?.type}:${r?.count}`).join(', ')}`);

    // Step 3: Find upsells
    const upsells = await findUpsells(results);
    console.log(`Upsells: ${upsells.length}`);

    // Step 4: Generate response
    const response = await generateResponse(message, results, upsells);
    console.log(`Response: ${response.substring(0, 100)}...`);

    res.json({
      success: true,
      response,
      debug: {
        intents: classification.intents,
        resultCounts: results.map(r => ({ type: r?.type, count: r?.count })),
        upsellCount: upsells.length
      }
    });

  } catch (error) {
    console.error('Sunny error:', error);
    res.status(500).json({ 
      success: false, 
      error: 'Something went wrong',
      response: "Sorry, I'm having a bit of trouble right now. Could you try again?"
    });
  }
});

// Greeting endpoint to test it's working
router.get('/health', (req: Request, res: Response) => {
  res.json({ status: 'Sunny is ready! ☀️' });
});

export default router;
