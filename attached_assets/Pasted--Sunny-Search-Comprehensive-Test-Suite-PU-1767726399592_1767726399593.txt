/**
 * Sunny Search - Comprehensive Test Suite
 * ========================================
 * 
 * PURPOSE: Determine if issues are DATA problems (fixable) or SEARCH problems (blocking)
 * 
 * PHASE 1: Data Audit - What actually exists in Awin feed?
 * PHASE 2: Search Quality - Does search find what exists?
 * PHASE 3: Filter Testing - Do dynamic filters work correctly?
 * PHASE 4: Edge Cases - Tricky queries that might break
 * 
 * Run: npx ts-node test-sunny.ts
 */

import { Pool } from 'pg';

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false
});

const API_URL = process.env.API_URL || 'http://localhost:8080';

interface TestResult {
  test: string;
  status: 'PASS' | 'FAIL' | 'DATA_GAP' | 'WARN';
  issue?: string;
  details?: any;
}

const results: TestResult[] = [];

// ============================================================
// PHASE 1: DATA AUDIT
// What actually exists in your Awin feed?
// ============================================================

async function phase1_DataAudit() {
  console.log('\n' + '='.repeat(60));
  console.log('PHASE 1: DATA AUDIT - What exists in Awin feed?');
  console.log('='.repeat(60) + '\n');

  // Total products
  const totalResult = await pool.query('SELECT COUNT(*) as count FROM products');
  console.log(`ðŸ“¦ Total products: ${parseInt(totalResult.rows[0].count).toLocaleString()}`);

  // Products with affiliate links
  const withLinksResult = await pool.query('SELECT COUNT(*) as count FROM products WHERE aw_deep_link IS NOT NULL');
  console.log(`ðŸ”— With affiliate links: ${parseInt(withLinksResult.rows[0].count).toLocaleString()}`);

  // Products with images
  const withImagesResult = await pool.query(`
    SELECT COUNT(*) as count FROM products 
    WHERE (merchant_image_url IS NOT NULL AND merchant_image_url != '') 
       OR (aw_image_url IS NOT NULL AND aw_image_url != '')
  `);
  console.log(`ðŸ–¼ï¸  With images: ${parseInt(withImagesResult.rows[0].count).toLocaleString()}`);

  // Top categories
  console.log('\nðŸ“‚ Top 10 Categories:');
  const categoriesResult = await pool.query(`
    SELECT category_name, COUNT(*) as count 
    FROM products 
    WHERE category_name IS NOT NULL 
    GROUP BY category_name 
    ORDER BY count DESC 
    LIMIT 10
  `);
  for (const row of categoriesResult.rows) {
    console.log(`   ${row.category_name}: ${parseInt(row.count).toLocaleString()}`);
  }

  // Top merchants
  console.log('\nðŸª Top 10 Merchants:');
  const merchantsResult = await pool.query(`
    SELECT merchant_name, COUNT(*) as count 
    FROM products 
    WHERE merchant_name IS NOT NULL 
    GROUP BY merchant_name 
    ORDER BY count DESC 
    LIMIT 10
  `);
  for (const row of merchantsResult.rows) {
    console.log(`   ${row.merchant_name}: ${parseInt(row.count).toLocaleString()}`);
  }

  // Key franchise counts
  console.log('\nðŸŽ¬ Franchise Product Counts:');
  const franchises = ['disney', 'marvel', 'peppa pig', 'paw patrol', 'frozen', 'spider-man', 'spiderman', 'lego', 'barbie', 'pokemon', 'harry potter', 'bluey'];
  
  for (const franchise of franchises) {
    const result = await pool.query(`
      SELECT COUNT(*) as count FROM products 
      WHERE LOWER(product_name) LIKE $1 OR LOWER(description) LIKE $1
    `, [`%${franchise}%`]);
    const count = parseInt(result.rows[0].count);
    const status = count > 100 ? 'âœ…' : count > 10 ? 'âš ï¸' : 'âŒ';
    console.log(`   ${status} ${franchise}: ${count.toLocaleString()}`);
  }

  // Category breakdown for key franchises
  console.log('\nðŸ“Š Disney Products by Category:');
  const disneyCategories = await pool.query(`
    SELECT category_name, COUNT(*) as count 
    FROM products 
    WHERE LOWER(product_name) LIKE '%disney%'
    GROUP BY category_name 
    ORDER BY count DESC 
    LIMIT 8
  `);
  for (const row of disneyCategories.rows) {
    console.log(`   ${row.category_name || 'Unknown'}: ${parseInt(row.count).toLocaleString()}`);
  }

  // Toys specifically
  console.log('\nðŸ§¸ TOY Products (category contains "toy"):');
  const toysResult = await pool.query(`
    SELECT COUNT(*) as count FROM products 
    WHERE LOWER(category_name) LIKE '%toy%'
  `);
  console.log(`   Total toys: ${parseInt(toysResult.rows[0].count).toLocaleString()}`);

  const disneyToysResult = await pool.query(`
    SELECT COUNT(*) as count FROM products 
    WHERE LOWER(category_name) LIKE '%toy%' 
    AND LOWER(product_name) LIKE '%disney%'
  `);
  console.log(`   Disney toys: ${parseInt(disneyToysResult.rows[0].count).toLocaleString()}`);

  const marvelToysResult = await pool.query(`
    SELECT COUNT(*) as count FROM products 
    WHERE LOWER(category_name) LIKE '%toy%' 
    AND (LOWER(product_name) LIKE '%marvel%' OR LOWER(product_name) LIKE '%spider%')
  `);
  console.log(`   Marvel toys: ${parseInt(marvelToysResult.rows[0].count).toLocaleString()}`);
}

// ============================================================
// PHASE 2: SEARCH QUALITY
// Does the search find what exists?
// ============================================================

async function phase2_SearchQuality() {
  console.log('\n' + '='.repeat(60));
  console.log('PHASE 2: SEARCH QUALITY - Does search find what exists?');
  console.log('='.repeat(60) + '\n');

  const testCases = [
    // Basic franchise searches
    { query: 'disney', expectMin: 5, description: 'Basic Disney search' },
    { query: 'disney toys', expectMin: 3, description: 'Disney + category modifier' },
    { query: 'marvel toys', expectMin: 3, description: 'Marvel toys' },
    { query: 'spider-man toys', expectMin: 3, description: 'Spider-Man toys (hyphenated)' },
    { query: 'spiderman toys', expectMin: 3, description: 'Spiderman toys (no hyphen)' },
    { query: 'paw patrol', expectMin: 2, description: 'Paw Patrol (two words)' },
    { query: 'peppa pig', expectMin: 2, description: 'Peppa Pig' },
    { query: 'frozen dress', expectMin: 2, description: 'Frozen + product type' },
    { query: 'lego', expectMin: 5, description: 'LEGO' },
    { query: 'harry potter', expectMin: 2, description: 'Harry Potter' },
    
    // Category searches
    { query: 'kids toys', expectMin: 5, description: 'Generic kids toys' },
    { query: 'children clothes', expectMin: 5, description: 'Children clothing' },
    { query: 'baby gifts', expectMin: 3, description: 'Baby gifts' },
    { query: 'outdoor toys', expectMin: 3, description: 'Outdoor toys' },
    { query: 'board games', expectMin: 3, description: 'Board games' },
    
    // Price-modified searches
    { query: 'toys under 20', expectMin: 3, description: 'Toys with price constraint' },
    { query: 'disney gifts under 15', expectMin: 2, description: 'Disney + price constraint' },
    
    // Specific products
    { query: 'lego star wars', expectMin: 2, description: 'LEGO Star Wars combo' },
    { query: 'disney princess', expectMin: 3, description: 'Disney Princess' },
    { query: 'minecraft', expectMin: 2, description: 'Minecraft' },
  ];

  for (const test of testCases) {
    try {
      // First check if data exists
      const words = test.query.toLowerCase().split(/\s+/).filter(w => w.length > 2);
      const conditions = words.map((_, i) => 
        `(LOWER(product_name) LIKE $${i + 1} OR LOWER(description) LIKE $${i + 1})`
      ).join(' AND ');
      const params = words.map(w => `%${w}%`);
      
      const dataCheck = await pool.query(
        `SELECT COUNT(*) as count FROM products WHERE ${conditions} AND aw_deep_link IS NOT NULL`,
        params
      );
      const dataExists = parseInt(dataCheck.rows[0].count);

      // Now test the search API
      const response = await fetch(`${API_URL}/api/search`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ query: test.query })
      });
      const data = await response.json();

      const returned = data.products?.length || 0;
      
      let status: TestResult['status'];
      let issue: string | undefined;

      if (dataExists === 0) {
        status = 'DATA_GAP';
        issue = `No products in feed matching "${test.query}"`;
      } else if (returned === 0) {
        status = 'FAIL';
        issue = `${dataExists} products exist but search returned 0 - SEARCH BUG`;
      } else if (returned < test.expectMin && dataExists >= test.expectMin) {
        status = 'WARN';
        issue = `Expected ${test.expectMin}+, got ${returned} (${dataExists} exist in data)`;
      } else {
        status = 'PASS';
      }

      const result: TestResult = {
        test: `"${test.query}" - ${test.description}`,
        status,
        issue,
        details: {
          dataExists,
          returned,
          totalCount: data.totalCount,
          filtersReturned: Object.keys(data.filters || {}).length > 0
        }
      };
      results.push(result);

      const icon = status === 'PASS' ? 'âœ…' : status === 'DATA_GAP' ? 'ðŸ“­' : status === 'WARN' ? 'âš ï¸' : 'âŒ';
      console.log(`${icon} ${test.query}: ${returned} returned (${dataExists} in DB) ${issue ? `- ${issue}` : ''}`);

    } catch (err) {
      results.push({
        test: `"${test.query}"`,
        status: 'FAIL',
        issue: `API error: ${err}`
      });
      console.log(`âŒ ${test.query}: API ERROR`);
    }
  }
}

// ============================================================
// PHASE 3: FILTER TESTING
// Do dynamic filters work correctly?
// ============================================================

async function phase3_FilterTesting() {
  console.log('\n' + '='.repeat(60));
  console.log('PHASE 3: FILTER TESTING - Do dynamic filters work?');
  console.log('='.repeat(60) + '\n');

  // Test 1: Search disney toys, then filter by merchant
  console.log('Test 3.1: Search "disney toys" then filter by merchant');
  try {
    const initial = await fetch(`${API_URL}/api/search`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ query: 'disney toys' })
    });
    const initialData = await initial.json();
    
    console.log(`   Initial results: ${initialData.products?.length || 0}`);
    console.log(`   Filters returned: ${JSON.stringify(Object.keys(initialData.filters || {}))}`);
    
    if (initialData.filters?.merchants?.length > 0) {
      const firstMerchant = initialData.filters.merchants[0].name;
      console.log(`   Filtering by merchant: ${firstMerchant}`);
      
      const filtered = await fetch(`${API_URL}/api/search`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ query: 'disney toys', merchant: firstMerchant })
      });
      const filteredData = await filtered.json();
      
      const allMatch = filteredData.products?.every((p: any) => p.merchant === firstMerchant);
      if (allMatch) {
        console.log(`   âœ… Merchant filter works - all ${filteredData.products.length} results from ${firstMerchant}`);
        results.push({ test: 'Merchant filter', status: 'PASS' });
      } else {
        console.log(`   âŒ Merchant filter failed - mixed merchants in results`);
        results.push({ test: 'Merchant filter', status: 'FAIL', issue: 'Mixed merchants after filtering' });
      }
    } else {
      console.log(`   âš ï¸ No merchant filters returned`);
      results.push({ test: 'Merchant filter', status: 'WARN', issue: 'No merchants in filters' });
    }
  } catch (err) {
    console.log(`   âŒ Error: ${err}`);
    results.push({ test: 'Merchant filter', status: 'FAIL', issue: String(err) });
  }

  // Test 2: Price filter
  console.log('\nTest 3.2: Search "lego" then filter by price');
  try {
    const initial = await fetch(`${API_URL}/api/search`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ query: 'lego' })
    });
    const initialData = await initial.json();
    
    if (initialData.filters?.prices?.length > 0) {
      const priceFilter = initialData.filters.prices[0];
      console.log(`   Filtering by price: ${priceFilter.label} (${priceFilter.min}-${priceFilter.max})`);
      
      const filtered = await fetch(`${API_URL}/api/search`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ query: 'lego', minPrice: priceFilter.min, maxPrice: priceFilter.max })
      });
      const filteredData = await filtered.json();
      
      const allInRange = filteredData.products?.every((p: any) => 
        p.price >= priceFilter.min && p.price < priceFilter.max
      );
      if (allInRange) {
        console.log(`   âœ… Price filter works - all ${filteredData.products.length} results in range`);
        results.push({ test: 'Price filter', status: 'PASS' });
      } else {
        console.log(`   âŒ Price filter failed - prices out of range`);
        results.push({ test: 'Price filter', status: 'FAIL', issue: 'Prices out of range' });
      }
    } else {
      console.log(`   âš ï¸ No price filters returned`);
      results.push({ test: 'Price filter', status: 'WARN', issue: 'No prices in filters' });
    }
  } catch (err) {
    console.log(`   âŒ Error: ${err}`);
    results.push({ test: 'Price filter', status: 'FAIL', issue: String(err) });
  }

  // Test 3: Category filter
  console.log('\nTest 3.3: Search "disney" then filter by category');
  try {
    const initial = await fetch(`${API_URL}/api/search`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ query: 'disney' })
    });
    const initialData = await initial.json();
    
    if (initialData.filters?.categories?.length > 0) {
      // Find a non-clothing category if possible
      const category = initialData.filters.categories.find((c: any) => 
        c.name.toLowerCase().includes('toy')
      ) || initialData.filters.categories[0];
      
      console.log(`   Filtering by category: ${category.name}`);
      
      const filtered = await fetch(`${API_URL}/api/search`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ query: 'disney', category: category.name })
      });
      const filteredData = await filtered.json();
      
      console.log(`   âœ… Category filter returned ${filteredData.products?.length || 0} results`);
      results.push({ test: 'Category filter', status: 'PASS' });
    } else {
      console.log(`   âš ï¸ No category filters returned`);
      results.push({ test: 'Category filter', status: 'WARN', issue: 'No categories in filters' });
    }
  } catch (err) {
    console.log(`   âŒ Error: ${err}`);
    results.push({ test: 'Category filter', status: 'FAIL', issue: String(err) });
  }
}

// ============================================================
// PHASE 4: EDGE CASES
// Tricky queries that might break
// ============================================================

async function phase4_EdgeCases() {
  console.log('\n' + '='.repeat(60));
  console.log('PHASE 4: EDGE CASES - Tricky queries');
  console.log('='.repeat(60) + '\n');

  const edgeCases = [
    { query: 'spider-man', description: 'Hyphenated word' },
    { query: 'spiderman', description: 'No hyphen version' },
    { query: "paw patrol", description: 'Two word franchise' },
    { query: 't-shirt', description: 'Hyphenated product' },
    { query: 'tshirt', description: 'No hyphen product' },
    { query: "mum's gift", description: 'Apostrophe' },
    { query: '5 year old', description: 'Numbers' },
    { query: 'age 3-5', description: 'Age range' },
    { query: 'LEGO', description: 'All caps' },
    { query: 'lego', description: 'All lowercase' },
    { query: 'LeGo', description: 'Mixed case' },
    { query: '', description: 'Empty query' },
    { query: 'a', description: 'Single character' },
    { query: 'the', description: 'Stop word only' },
    { query: 'disney marvel lego', description: 'Multiple brands' },
  ];

  for (const test of edgeCases) {
    try {
      const response = await fetch(`${API_URL}/api/search`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ query: test.query })
      });
      const data = await response.json();
      
      const returned = data.products?.length || 0;
      const hasError = data.error;
      
      if (hasError) {
        console.log(`âš ï¸ "${test.query}" (${test.description}): Handled error - ${data.error}`);
        results.push({ test: `Edge: ${test.description}`, status: 'PASS', details: 'Error handled gracefully' });
      } else {
        console.log(`âœ… "${test.query}" (${test.description}): ${returned} results`);
        results.push({ test: `Edge: ${test.description}`, status: 'PASS', details: { returned } });
      }
    } catch (err) {
      console.log(`âŒ "${test.query}" (${test.description}): CRASHED - ${err}`);
      results.push({ test: `Edge: ${test.description}`, status: 'FAIL', issue: String(err) });
    }
  }
}

// ============================================================
// FINAL REPORT
// ============================================================

async function generateReport() {
  console.log('\n' + '='.repeat(60));
  console.log('FINAL REPORT');
  console.log('='.repeat(60) + '\n');

  const passed = results.filter(r => r.status === 'PASS').length;
  const failed = results.filter(r => r.status === 'FAIL').length;
  const dataGaps = results.filter(r => r.status === 'DATA_GAP').length;
  const warnings = results.filter(r => r.status === 'WARN').length;

  console.log(`âœ… PASSED: ${passed}`);
  console.log(`âŒ FAILED: ${failed}`);
  console.log(`ðŸ“­ DATA GAPS: ${dataGaps}`);
  console.log(`âš ï¸  WARNINGS: ${warnings}`);

  console.log('\n--- VERDICT ---');
  
  if (failed === 0) {
    console.log('ðŸŽ‰ SEARCH LOGIC IS WORKING');
    console.log('   All failures are DATA issues, not SEARCH bugs.');
    console.log('   You can demo this confidently.');
  } else {
    console.log('ðŸš¨ SEARCH BUGS DETECTED');
    console.log('   The following need fixing before demo:');
    for (const fail of results.filter(r => r.status === 'FAIL')) {
      console.log(`   - ${fail.test}: ${fail.issue}`);
    }
  }

  if (dataGaps > 0) {
    console.log('\n--- DATA GAPS (Fixable by adding Awin merchants) ---');
    for (const gap of results.filter(r => r.status === 'DATA_GAP')) {
      console.log(`   ðŸ“­ ${gap.test}`);
    }
  }

  // Output raw JSON for detailed analysis
  console.log('\n--- RAW JSON OUTPUT ---');
  console.log(JSON.stringify({
    summary: {
      passed,
      failed,
      dataGaps,
      warnings,
      verdict: failed === 0 ? 'SEARCH_OK' : 'SEARCH_BUGS'
    },
    results
  }, null, 2));
}

// ============================================================
// RUN ALL TESTS
// ============================================================

async function runAllTests() {
  console.log('ðŸ§ª SUNNY SEARCH - COMPREHENSIVE TEST SUITE');
  console.log('==========================================\n');
  console.log('Testing against:', API_URL);
  console.log('Started:', new Date().toISOString());

  try {
    await phase1_DataAudit();
    await phase2_SearchQuality();
    await phase3_FilterTesting();
    await phase4_EdgeCases();
    await generateReport();
  } catch (err) {
    console.error('Test suite crashed:', err);
  } finally {
    await pool.end();
  }
}

runAllTests();
