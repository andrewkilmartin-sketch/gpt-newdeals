# SUNNY AUDIT TEST v2 - With AI Relevance Scoring

## Overview

This audit script will:
1. Run each test query through Sunny's search
2. Capture all 8 results returned
3. Use Claude API to score EACH result for relevance (1-5)
4. Calculate an overall relevance score per query
5. Flag specific failure types
6. Output detailed CSV for analysis

---

## PART 1: Configuration

```javascript
// ============================================
// CONFIGURATION
// ============================================

const ANTHROPIC_API_KEY = process.env.ANTHROPIC_API_KEY; // or hardcode for testing
const CLAUDE_MODEL = 'claude-sonnet-4-20250514';

// Scoring thresholds
const SCORE_THRESHOLDS = {
  EXCELLENT: 4.5,  // Average 4.5+ = excellent search
  GOOD: 3.5,       // Average 3.5+ = acceptable
  POOR: 2.5,       // Average 2.5+ = needs improvement
  FAIL: 0          // Below 2.5 = broken
};

// Inappropriate content that should NEVER appear (auto-score 0)
const INAPPROPRIATE_TERMS = [
  'bedroom confidence', 'erectile', 'viagra', 'sexual health',
  'reproductive health', 'your status', 'sti test', 'std test',
  'reclaim your confidence', 'regain confidence', 'dating site',
  'singles near', 'gambling', 'casino', 'betting', 'weight loss pill',
  'diet pill', 'slimming tablet', 'beer delivery', 'wine subscription',
  'alcohol delivery', 'cigarette', 'vape juice', 'cbd oil', 'adult toy',
  'lingerie', 'sexy', 'erotic'
];

// Family platform context for AI scoring
const PLATFORM_CONTEXT = `
Sunny is a UK family concierge platform helping parents find:
- Toys and gifts for children (ages 0-16)
- Family days out and attractions
- Kids clothing and shoes
- Family-friendly experiences
- Cinema and entertainment for families
- Party supplies and celebrations

Users are parents/grandparents shopping for children or planning family activities.
`;
```

---

## PART 2: AI Relevance Scoring Function

```javascript
// ============================================
// AI RELEVANCE SCORER
// ============================================

async function scoreResultRelevance(query, result, resultIndex) {
  // Quick check for inappropriate content - auto-score 0
  const resultText = ((result.title || '') + ' ' + (result.description || '')).toLowerCase();
  for (const term of INAPPROPRIATE_TERMS) {
    if (resultText.includes(term)) {
      return {
        score: 0,
        reason: `INAPPROPRIATE: Contains "${term}"`,
        flagged: true
      };
    }
  }
  
  // If result is empty/null, score 0
  if (!result || !result.title) {
    return {
      score: 0,
      reason: 'NO_RESULT: Empty result slot',
      flagged: false
    };
  }

  // Call Claude to score relevance
  const prompt = `You are evaluating search results for a UK family platform called "Sunny" that helps parents find products, activities, and experiences for their children.

${PLATFORM_CONTEXT}

USER'S SEARCH QUERY: "${query}"

RESULT #${resultIndex + 1}:
- Title: ${result.title || 'N/A'}
- Merchant: ${result.merchant || 'N/A'}
- Description: ${(result.description || '').substring(0, 200)}
- Price: ${result.price || 'N/A'}

SCORING CRITERIA:
5 = PERFECT: Exactly what the user wanted, highly relevant to query and appropriate for families
4 = GOOD: Relevant to the query, makes sense as a result, family-appropriate
3 = ACCEPTABLE: Somewhat related, user might find it useful, not ideal
2 = POOR: Weak connection to query, probably not what user wanted
1 = IRRELEVANT: No meaningful connection to what user searched for
0 = HARMFUL/WRONG: Inappropriate for family platform OR completely wrong category (e.g., car rental for "book tokens")

IMPORTANT CONSIDERATIONS:
- "book tokens" should return book gift vouchers, NOT booking.com/car rental/hotels
- "party bags" should return party supplies, NOT fashion handbags
- "X year old" refers to child's age, NOT warranty periods
- "best toys" should return quality/popular toys, NOT just cheapest
- Results should be FAMILY APPROPRIATE - no adult content, alcohol, gambling, dating

Respond with ONLY a JSON object:
{
  "score": <0-5>,
  "reason": "<brief 10-word max explanation>"
}`;

  try {
    const response = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': ANTHROPIC_API_KEY,
        'anthropic-version': '2023-06-01'
      },
      body: JSON.stringify({
        model: CLAUDE_MODEL,
        max_tokens: 100,
        messages: [{ role: 'user', content: prompt }]
      })
    });

    const data = await response.json();
    const content = data.content[0].text;
    
    // Parse JSON response
    const jsonMatch = content.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      const parsed = JSON.parse(jsonMatch[0]);
      return {
        score: Math.min(5, Math.max(0, parsed.score)),
        reason: parsed.reason || 'No reason provided',
        flagged: parsed.score <= 1
      };
    }
  } catch (error) {
    console.error(`Scoring error for "${query}" result ${resultIndex}:`, error.message);
  }
  
  // Default if API fails
  return {
    score: -1,
    reason: 'SCORING_ERROR: API call failed',
    flagged: false
  };
}
```

---

## PART 3: Main Audit Function

```javascript
// ============================================
// MAIN AUDIT FUNCTION
// ============================================

async function auditQuery(query, searchFunction) {
  const startTime = Date.now();
  
  // Run the search
  let results = [];
  let dbCount = 0;
  let error = null;
  
  try {
    const searchResponse = await searchFunction(query);
    results = searchResponse.results || [];
    dbCount = searchResponse.totalInDatabase || 0;
  } catch (e) {
    error = e.message;
  }
  
  const responseTime = Date.now() - startTime;
  
  // Pad results to 8 slots
  while (results.length < 8) {
    results.push(null);
  }
  results = results.slice(0, 8);
  
  // Score each result with AI
  const scoredResults = [];
  for (let i = 0; i < 8; i++) {
    if (results[i]) {
      const scored = await scoreResultRelevance(query, results[i], i);
      scoredResults.push({
        title: results[i].title || '',
        merchant: results[i].merchant || '',
        price: results[i].price || '',
        score: scored.score,
        reason: scored.reason,
        flagged: scored.flagged
      });
    } else {
      scoredResults.push({
        title: '',
        merchant: '',
        price: '',
        score: 0,
        reason: 'EMPTY_SLOT',
        flagged: false
      });
    }
    
    // Small delay to avoid rate limiting
    await new Promise(r => setTimeout(r, 100));
  }
  
  // Calculate overall scores
  const validScores = scoredResults.filter(r => r.score >= 0 && r.title !== '');
  const avgScore = validScores.length > 0 
    ? validScores.reduce((sum, r) => sum + r.score, 0) / validScores.length 
    : 0;
  
  const relevancePercent = Math.round((avgScore / 5) * 100);
  const flaggedCount = scoredResults.filter(r => r.flagged).length;
  const resultCount = scoredResults.filter(r => r.title !== '').length;
  
  // Determine verdict
  let verdict = 'PASS';
  let fixAction = '';
  
  if (error) {
    verdict = 'ERROR';
    fixAction = error;
  } else if (resultCount === 0 && dbCount > 0) {
    verdict = 'SEARCH_BUG';
    fixAction = 'DB has products but search returned none';
  } else if (resultCount === 0) {
    verdict = 'INVENTORY_GAP';
    fixAction = 'No products in database for this query';
  } else if (flaggedCount > 0) {
    verdict = 'FLAGGED_CONTENT';
    fixAction = `${flaggedCount} results flagged as inappropriate/irrelevant`;
  } else if (avgScore < 2.0) {
    verdict = 'POOR_RELEVANCE';
    fixAction = `Average score ${avgScore.toFixed(1)}/5 - results not matching query`;
  } else if (avgScore < 3.0) {
    verdict = 'WEAK_RELEVANCE';
    fixAction = `Average score ${avgScore.toFixed(1)}/5 - results could be better`;
  }
  
  return {
    query,
    verdict,
    dbCount,
    resultCount,
    avgScore: avgScore.toFixed(2),
    relevancePercent,
    flaggedCount,
    timeMs: responseTime,
    result1_title: scoredResults[0].title,
    result1_score: scoredResults[0].score,
    result1_reason: scoredResults[0].reason,
    result2_title: scoredResults[1].title,
    result2_score: scoredResults[1].score,
    result2_reason: scoredResults[1].reason,
    result3_title: scoredResults[2].title,
    result3_score: scoredResults[2].score,
    result3_reason: scoredResults[2].reason,
    result4_title: scoredResults[3].title,
    result4_score: scoredResults[3].score,
    result4_reason: scoredResults[3].reason,
    result5_title: scoredResults[4].title,
    result5_score: scoredResults[4].score,
    result5_reason: scoredResults[4].reason,
    result6_title: scoredResults[5].title,
    result6_score: scoredResults[5].score,
    result6_reason: scoredResults[5].reason,
    result7_title: scoredResults[6].title,
    result7_score: scoredResults[6].score,
    result7_reason: scoredResults[6].reason,
    result8_title: scoredResults[7].title,
    result8_score: scoredResults[7].score,
    result8_reason: scoredResults[7].reason,
    fixAction
  };
}
```

---

## PART 4: CSV Export

```javascript
// ============================================
// CSV GENERATION
// ============================================

const CSV_HEADERS = [
  'query',
  'verdict', 
  'dbCount',
  'resultCount',
  'avgScore',
  'relevancePercent',
  'flaggedCount',
  'timeMs',
  'result1_title', 'result1_score', 'result1_reason',
  'result2_title', 'result2_score', 'result2_reason',
  'result3_title', 'result3_score', 'result3_reason',
  'result4_title', 'result4_score', 'result4_reason',
  'result5_title', 'result5_score', 'result5_reason',
  'result6_title', 'result6_score', 'result6_reason',
  'result7_title', 'result7_score', 'result7_reason',
  'result8_title', 'result8_score', 'result8_reason',
  'fixAction'
].join(',');

function escapeCSV(value) {
  if (value === null || value === undefined) return '';
  const str = String(value);
  if (str.includes(',') || str.includes('"') || str.includes('\n')) {
    return `"${str.replace(/"/g, '""')}"`;
  }
  return str;
}

function auditRowToCSV(row) {
  return [
    row.query,
    row.verdict,
    row.dbCount,
    row.resultCount,
    row.avgScore,
    row.relevancePercent,
    row.flaggedCount,
    row.timeMs,
    row.result1_title, row.result1_score, row.result1_reason,
    row.result2_title, row.result2_score, row.result2_reason,
    row.result3_title, row.result3_score, row.result3_reason,
    row.result4_title, row.result4_score, row.result4_reason,
    row.result5_title, row.result5_score, row.result5_reason,
    row.result6_title, row.result6_score, row.result6_reason,
    row.result7_title, row.result7_score, row.result7_reason,
    row.result8_title, row.result8_score, row.result8_reason,
    row.fixAction
  ].map(escapeCSV).join(',');
}
```

---

## PART 5: Batch Runner with Progress

```javascript
// ============================================
// BATCH AUDIT RUNNER
// ============================================

async function runFullAudit(queries, searchFunction, outputPath) {
  console.log(`\nðŸš€ Starting Sunny Audit v2 - ${queries.length} queries\n`);
  console.log('=' .repeat(60));
  
  const results = [];
  const startTime = Date.now();
  
  // Summary counters
  const summary = {
    total: queries.length,
    pass: 0,
    searchBug: 0,
    inventoryGap: 0,
    flaggedContent: 0,
    poorRelevance: 0,
    weakRelevance: 0,
    error: 0,
    totalRelevanceScore: 0,
    scoredCount: 0
  };
  
  for (let i = 0; i < queries.length; i++) {
    const query = queries[i].trim();
    if (!query) continue;
    
    // Progress indicator
    const progress = Math.round((i / queries.length) * 100);
    process.stdout.write(`\r[${progress}%] Processing: "${query.substring(0, 40)}..."`.padEnd(70));
    
    try {
      const result = await auditQuery(query, searchFunction);
      results.push(result);
      
      // Update summary
      switch (result.verdict) {
        case 'PASS': summary.pass++; break;
        case 'SEARCH_BUG': summary.searchBug++; break;
        case 'INVENTORY_GAP': summary.inventoryGap++; break;
        case 'FLAGGED_CONTENT': summary.flaggedContent++; break;
        case 'POOR_RELEVANCE': summary.poorRelevance++; break;
        case 'WEAK_RELEVANCE': summary.weakRelevance++; break;
        case 'ERROR': summary.error++; break;
      }
      
      if (result.avgScore > 0) {
        summary.totalRelevanceScore += parseFloat(result.avgScore);
        summary.scoredCount++;
      }
      
    } catch (e) {
      console.error(`\nError on query "${query}":`, e.message);
      results.push({
        query,
        verdict: 'ERROR',
        fixAction: e.message,
        avgScore: 0,
        relevancePercent: 0
      });
      summary.error++;
    }
    
    // Rate limiting pause every 10 queries
    if (i % 10 === 0) {
      await new Promise(r => setTimeout(r, 500));
    }
  }
  
  // Write CSV
  const csvContent = [CSV_HEADERS, ...results.map(auditRowToCSV)].join('\n');
  const fs = require('fs');
  fs.writeFileSync(outputPath, csvContent);
  
  // Calculate final stats
  const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
  const avgRelevance = summary.scoredCount > 0 
    ? (summary.totalRelevanceScore / summary.scoredCount).toFixed(2)
    : 0;
  const overallRelevancePercent = Math.round((avgRelevance / 5) * 100);
  
  // Print summary
  console.log('\n\n' + '='.repeat(60));
  console.log('ðŸ“Š AUDIT COMPLETE - SUMMARY');
  console.log('='.repeat(60));
  console.log(`
Total Queries:        ${summary.total}
Time Elapsed:         ${elapsed}s

VERDICTS:
  âœ… PASS:             ${summary.pass} (${pct(summary.pass, summary.total)}%)
  ðŸ” SEARCH_BUG:       ${summary.searchBug} (${pct(summary.searchBug, summary.total)}%)
  ðŸ“¦ INVENTORY_GAP:    ${summary.inventoryGap} (${pct(summary.inventoryGap, summary.total)}%)
  ðŸš© FLAGGED_CONTENT:  ${summary.flaggedContent} (${pct(summary.flaggedContent, summary.total)}%)
  ðŸ˜ POOR_RELEVANCE:   ${summary.poorRelevance} (${pct(summary.poorRelevance, summary.total)}%)
  ðŸ¤· WEAK_RELEVANCE:   ${summary.weakRelevance} (${pct(summary.weakRelevance, summary.total)}%)
  âŒ ERROR:            ${summary.error} (${pct(summary.error, summary.total)}%)

RELEVANCE SCORE:
  Average Score:       ${avgRelevance}/5.0
  Overall Relevance:   ${overallRelevancePercent}%

Output saved to: ${outputPath}
`);
  
  console.log('='.repeat(60));
  
  return { results, summary };
}

function pct(count, total) {
  return total > 0 ? Math.round((count / total) * 100) : 0;
}
```

---

## PART 6: How to Run

```javascript
// ============================================
// EXAMPLE USAGE
// ============================================

// Your existing search function - adapt to match your API
async function sunnySearch(query) {
  const response = await fetch(`YOUR_API_ENDPOINT/search?q=${encodeURIComponent(query)}`);
  const data = await response.json();
  return {
    results: data.products || data.results || [],
    totalInDatabase: data.dbCount || data.total || 0
  };
}

// Load test queries
const fs = require('fs');
const queries = fs.readFileSync('test-queries.txt', 'utf8')
  .split('\n')
  .filter(q => q.trim() && !q.startsWith('#'));

// Run audit
runFullAudit(queries, sunnySearch, 'audit-results-with-scores.csv')
  .then(({ summary }) => {
    console.log('\nâœ… Audit complete!');
    process.exit(summary.error > 0 ? 1 : 0);
  })
  .catch(err => {
    console.error('Fatal error:', err);
    process.exit(1);
  });
```

---

## PART 7: Example Output CSV

```csv
query,verdict,dbCount,resultCount,avgScore,relevancePercent,flaggedCount,timeMs,result1_title,result1_score,result1_reason,result2_title,result2_score,result2_reason,...,fixAction
"dinosaur toys",PASS,417,8,4.25,85,0,342,"Jurassic World Dinosaur Playset",5,"Perfect match for query","T-Rex Soft Toy",4,"Good dinosaur toy option",...,""
"book tokens",POOR_RELEVANCE,7976,8,1.50,30,2,289,"Book your next car rental",0,"Wrong - car rental not book vouchers","Holiday booking deals",0,"Wrong - travel not books",...,"Average score 1.50/5 - results not matching query"
"impulse control",FLAGGED_CONTENT,2,3,0.33,7,2,445,"Take Control of Your Reproductive Health",0,"INAPPROPRIATE: Contains 'reproductive health'",...,"2 results flagged as inappropriate/irrelevant"
```

---

## What This Gives You

| Metric | What It Tells You |
|--------|-------------------|
| `avgScore` | Real relevance 0-5 for this query |
| `relevancePercent` | Percentage score (avgScore/5 * 100) |
| `flaggedCount` | How many results were inappropriate/irrelevant |
| `result1_score` through `result8_score` | Individual score for each result |
| `result1_reason` through `result8_reason` | WHY each result got that score |
| `verdict` | Overall pass/fail category |

---

## Cost Estimate

Each query scores 8 results = 8 Claude API calls
- 5000 queries Ã— 8 = 40,000 API calls
- ~100 tokens per call = 4M tokens
- Sonnet: ~$12-15 for full audit

**Suggestion:** Run on 500 query sample first (~$1.50) to validate before full run.

---

## Quick Test (10 queries)

```javascript
const testQueries = [
  'dinosaur toys',
  'book tokens', 
  'party bag fillers',
  'best toys for 5 year old',
  'impulse control',
  'birthday gift for girl',
  'frozen toys',
  'essentials for 7 year old',
  'top toys 2025',
  'trampoline park near me'
];

runFullAudit(testQueries, sunnySearch, 'test-audit.csv');
```

Run this first to see the new format before doing the full 5000!
